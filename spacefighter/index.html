<!DOCTYPE html>
<html lang="no">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>SpaceFighters</title>
   <style>
       @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');


       body {
           margin: 0;
           padding: 0;
           background-color: #050510;
           overflow: hidden;
           font-family: 'Press Start 2P', cursive;
           touch-action: none;
           color: #fff;
           user-select: none;
       }


       #gameContainer {
           position: relative;
           width: 100vw;
           height: 100vh;
           display: flex;
           justify-content: center;
           align-items: center;
           background: #000;
       }


       canvas {
           background-color: #000;
           box-shadow: 0 0 50px rgba(0, 100, 255, 0.2);
           image-rendering: pixelated;
           border: 4px solid #222;
       }


       .scanlines {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: linear-gradient(
               to bottom,
               rgba(255,255,255,0),
               rgba(255,255,255,0) 50%,
               rgba(0,0,0,0.1) 50%,
               rgba(0,0,0,0.1)
           );
           background-size: 100% 4px;
           pointer-events: none;
           z-index: 5;
           mix-blend-mode: overlay;
       }


       #uiLayer {
           position: absolute;
           top: 10px;
           left: 10px;
           width: calc(100% - 20px);
           color: #0ff;
           font-size: 10px;
           pointer-events: none;
           text-shadow: 2px 2px 0 #000;
           z-index: 10;
           display: flex;
           justify-content: space-between;
       }


       .hud-column {
           display: flex;
           flex-direction: column;
           gap: 5px;
       }


       #startScreen, #gameOverScreen, #levelScreen, #bossWarning {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.85);
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           z-index: 20;
           text-align: center;
       }


       #levelScreen, #bossWarning {
           background: transparent;
           pointer-events: none;
           transition: opacity 0.5s;
       }


       #bossWarning h1 {
           color: #f00;
           font-size: 40px;
           animation: flash 0.2s infinite;
       }


       @keyframes flash {
           0% { opacity: 1; }
           50% { opacity: 0; }
           100% { opacity: 1; }
       }


       h1 {
           font-size: 32px;
           margin-bottom: 20px;
           color: #f0f;
           text-shadow: 4px 4px 0px #0ff;
           line-height: 1.5;
       }
      
       .big-text {
           font-size: 48px;
           color: #ff0;
           text-shadow: 4px 4px #f00;
           animation: pulse 1s infinite alternate;
       }


       @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
      
       button {
           padding: 20px 40px;
           font-size: 16px;
           font-family: 'Press Start 2P', cursive;
           background: #0ff;
           color: #000;
           border: 4px solid #fff;
           cursor: pointer;
           text-transform: uppercase;
           box-shadow: 0 6px 0 #008888;
           margin-top: 20px;
       }


       button:hover { background: #fff; transform: translateY(-2px); }
       button:active { transform: translateY(2px); box-shadow: 0 2px 0 #008888; }


       .hidden { display: none !important; opacity: 0; }


       .bar-container {
           width: 140px;
           height: 8px;
           background: #222;
           border: 2px solid #555;
           margin-top: 2px;
           position: relative;
       }


       .bar-label { margin-top: 5px; color: #aaa; font-size: 8px; }


       #healthBar { width: 100%; height: 100%; background: #0f0; transition: width 0.1s; }
       #fuelBar { width: 100%; height: 100%; background: #f90; transition: width 0.1s; }
       #shieldBar { width: 0%; height: 100%; background: #0af; transition: width 0.1s; }
      
       #bossHealthContainer {
           position: absolute;
           top: 40px;
           left: 50%;
           transform: translateX(-50%);
           width: 70%;
           height: 15px;
           background: #300;
           border: 2px solid #f00;
           display: none;
           z-index: 15;
           box-shadow: 0 0 10px #f00;
       }
       #bossHealthBar { width: 100%; height: 100%; background: #f00; transition: width 0.2s; }
      
       .key-hint {
           display: inline-block;
           background: #333;
           color: #fff;
           padding: 2px 4px;
           border-radius: 2px;
           margin-right: 5px;
           font-size: 8px;
           border: 1px solid #555;
       }


       #shieldTimer {
           position: absolute;
           top: -20px;
           right: 0;
           color: #0af;
           font-weight: bold;
       }
      
       .levelup-text {
           position: absolute;
           color: #ff0;
           font-size: 20px;
           font-weight: bold;
           text-shadow: 2px 2px #f00;
           pointer-events: none;
           animation: floatUp 1s forwards;
           z-index: 100;
       }
      
       @keyframes floatUp {
           0% { transform: translateY(0); opacity: 1; }
           100% { transform: translateY(-50px); opacity: 0; }
       }


   </style>
</head>
<body>


<div id="gameContainer">
   <canvas id="gameCanvas"></canvas>
   <div class="scanlines"></div>
  
   <div id="bossHealthContainer">
       <div id="bossHealthBar"></div>
   </div>


   <div id="uiLayer" class="hidden">
       <div class="hud-column">
           <div>SCORE: <span id="scoreDisplay">0</span></div>
           <div>STAGE: <span id="stageDisplay">1</span></div>
           <div class="bar-label">FUEL</div>
           <div class="bar-container"><div id="fuelBar"></div></div>
       </div>
       <div class="hud-column" style="text-align: right; align-items: flex-end;">
           <div>
               <span id="keyHintDisplay" class="key-hint">1</span>
               <span id="weaponDisplay" style="color: #ff0;">PLASMA</span>
               <span id="levelDisplay" style="font-size:8px; color:#aaa;">LVL 1</span>
           </div>
           <div class="bar-label">HELSE</div>
           <div class="bar-container"><div id="healthBar"></div></div>
           <div class="bar-label" id="shieldLabel" style="color:#0af; opacity:0;">SKJOLD</div>
           <div class="bar-container" style="border-color:#05a;">
               <div id="shieldTimer"></div>
               <div id="shieldBar"></div>
           </div>
       </div>
   </div>


   <div id="startScreen">
       <h1>SpaceFighters</h1>
       <p style="color: #ccc; font-size: 10px; line-height: 2;">
           [W A S D] STYR • [SPACE] SKYT<br><br>
           BYTT VÅPEN: [1][2][3][4][5]<br><br>
           ⚠️ FARE ⚠️<br>
           BANEN GÅR RASKERE OG RASKERE!<br>
           UNNGÅ VEGGENE - DE STOPPER SKUDD!<br><br>
           LYD ANBEFALES!
       </p>
       <button id="startBtn">START MISSION</button>
   </div>


   <div id="levelScreen" class="hidden">
       <h1 class="big-text" id="levelTitle">STAGE 1</h1>
   </div>


   <div id="bossWarning" class="hidden">
       <h1>ADVARSEL</h1>
       <p>GIGANTISK FIENDE</p>
   </div>


   <div id="gameOverScreen" class="hidden">
       <h1 style="color: #f00;">GAME OVER</h1>
       <p style="color: #fff; margin-bottom: 20px;">SCORE: <span id="finalScore" style="color: #ff0;">0</span></p>
       <div id="deathReason" style="color: #f90; font-size: 12px; margin-bottom: 20px;"></div>
       <button id="restartBtn">PRØV IGJEN</button>
   </div>
</div>


<script>
/**
* AUDIO ENGINE
*/
const AudioSys = {
   ctx: null, isPlaying: false, nextNoteTime: 0, noteIndex: 0, bar: 0, tempo: 138,
   init: function() {
       if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
       if (this.ctx.state === 'suspended') this.ctx.resume();
   },
   playTone: function(freq, type, duration, vol=0.1, slide=0) {
       if (!this.ctx) return;
       const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
       osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
       if (slide !== 0) osc.frequency.exponentialRampToValueAtTime(Math.max(10, freq + slide), this.ctx.currentTime + duration);
       gain.gain.setValueAtTime(vol, this.ctx.currentTime);
       gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
       osc.connect(gain); gain.connect(this.ctx.destination);
       osc.start(); osc.stop(this.ctx.currentTime + duration);
   },
   playNoise: function(duration, vol=0.2, filterFreq=null) {
       if (!this.ctx) return;
       const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
       const data = buf.getChannelData(0); for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
       const noise = this.ctx.createBufferSource(); noise.buffer = buf;
       const gain = this.ctx.createGain();
       if (filterFreq) {
           const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = filterFreq;
           noise.connect(f); f.connect(gain);
       } else noise.connect(gain);
       gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
       gain.connect(this.ctx.destination); noise.start();
   },
   sfxShoot: function(type) {
       if (!this.ctx) return;
       if(type === 'RAPID') this.playTone(800, 'sawtooth', 0.1, 0.05, -300);
       else if(type === 'BOMB') { this.playTone(100, 'square', 0.2, 0.1, -50); this.playNoise(0.2, 0.1, 800); }
       else if(type === 'SWIRL') this.playTone(600, 'sine', 0.3, 0.05, 600);
       else if(type === 'SPREAD') { this.playTone(300, 'square', 0.1, 0.1, -100); this.playNoise(0.1, 0.1, 2000); }
       else this.playTone(400, 'square', 0.1, 0.05, -100);
   },
   sfxExplosion: function() { this.playNoise(0.5, 0.4, 1000); this.playTone(50, 'sawtooth', 0.5, 0.3, -20); },
   sfxPowerup: function() { this.playTone(440, 'sine', 0.1, 0.1); setTimeout(() => this.playTone(880, 'sine', 0.3, 0.1), 100); },
   sfxLevelUp: function() {
       this.playTone(440, 'square', 0.1, 0.1);
       setTimeout(() => this.playTone(554, 'square', 0.1, 0.1), 100);
       setTimeout(() => this.playTone(659, 'square', 0.4, 0.1), 200);
   },
   sfxFuel: function() {
       const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
       o.frequency.setValueAtTime(200, this.ctx.currentTime); o.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.5);
       g.gain.setValueAtTime(0.2, this.ctx.currentTime); g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
       o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + 0.5);
   },
   startMusic: function() { this.isPlaying = true; this.nextNoteTime = this.ctx.currentTime; this.noteIndex = 0; this.bar = 0; this.scheduler(); },
   stopMusic: function() { this.isPlaying = false; },
   scheduler: function() {
       if (!this.isPlaying) return;
       while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
           this.playBeat(this.nextNoteTime, this.noteIndex, this.bar);
           this.nextNoteTime += 60.0 / this.tempo / 4;
           this.noteIndex++;
           if (this.noteIndex >= 16) { this.noteIndex = 0; this.bar = (this.bar + 1) % 8; }
       }
       setTimeout(() => this.scheduler(), 25);
   },
   playBeat: function(time, step, bar) {
       const roots = [55,55, 43.65,43.65, 65.4,65.4, 49,49];
       const root = roots[bar];


       if (step % 4 === 0) {
           const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
           osc.frequency.setValueAtTime(120, time); osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.3);
           gain.gain.setValueAtTime(0.8, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
           osc.connect(gain); gain.connect(this.ctx.destination); osc.start(time); osc.stop(time + 0.3);
       }
      
       if (step % 4 === 2) this.playNoise(0.1, 0.15, 8000);


       if (true) {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sawtooth';
            const freq = (step % 4 === 2) ? root * 2 : root;
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(0.2, time); gain.gain.linearRampToValueAtTime(0, time + 0.15);
            osc.connect(gain); gain.connect(this.ctx.destination); osc.start(time); osc.stop(time + 0.2);
       }


       let melodyNote = 0;
       if (bar % 2 === 0) {
           if (step === 0) melodyNote = 880;  
           if (step === 3) melodyNote = 1046.5;
           if (step === 6) melodyNote = 880;  
       } else {
           if (step === 0) melodyNote = 783.99;
           if (step === 3) melodyNote = 880;  
           if (step === 6) melodyNote = 659.25;
       }


       if (melodyNote > 0) {
           const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
           osc.type = 'square';
           osc.frequency.setValueAtTime(melodyNote, time);
           const lfo = this.ctx.createOscillator(); lfo.frequency.value = 5;
           const lfoGain = this.ctx.createGain(); lfoGain.gain.value = 10;
           lfo.connect(lfoGain); lfoGain.connect(osc.frequency); lfo.start(time);
           gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
           osc.connect(gain); gain.connect(this.ctx.destination); osc.start(time); osc.stop(time + 0.3);
       }
   }
};


/**
* GRAFIKK OG SPRITES
*/
const pixelSize = 3;


const SPRITES = {
   PLAYER: [[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,4,2,4,1,1,0,0,0,0,0,0],[0,0,0,0,0,1,1,1,4,1,4,1,1,1,0,0,0,0,0],[0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],[0,0,0,1,4,1,1,1,1,1,1,1,1,1,4,1,0,0,0],[0,0,1,1,4,4,1,1,1,1,1,1,1,4,4,1,1,0,0],[0,1,1,1,4,4,4,1,1,2,1,1,4,4,4,1,1,1,0],[1,1,1,1,1,1,1,1,4,2,4,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,4,4,4,4,4,1,1,1,1,1,1,1],[1,4,4,1,0,1,1,4,4,4,4,4,1,1,0,1,4,4,1],[1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1],[0,1,1,0,0,0,1,3,1,1,1,3,1,0,0,0,1,1,0],[0,0,0,0,0,0,1,3,1,0,1,3,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0]],
   ENEMY_BUG: [[0,0,1,0,0,0,1,0,0],[0,1,1,1,1,1,1,1,0],[1,1,2,1,2,1,2,1,1],[1,1,2,2,2,2,2,1,1],[0,1,0,1,0,1,0,1,0],[0,1,0,0,0,0,0,1,0]],
   ENEMY_DART: [[0,0,0,1,0,0,0],[0,0,1,2,1,0,0],[0,1,1,2,1,1,0],[1,1,2,2,2,1,1],[1,0,1,3,1,0,1],[0,0,1,0,1,0,0]],
   ENEMY_ASSAULT: [[0,0,1,1,1,1,1,0,0],[0,1,2,2,2,2,2,1,0],[1,2,2,3,3,2,2,2,1],[1,2,2,2,2,2,2,2,1],[0,1,1,2,2,2,1,1,0],[0,0,1,1,1,1,1,0,0]],
   METEOR: [[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],[0,0,1,2,2,2,2,2,2,1,1,0,0,0,0,0],[0,1,2,2,3,3,2,2,2,2,2,1,0,0,0,0],[0,1,2,3,3,3,2,2,2,2,2,2,1,0,0,0],[1,2,2,3,3,2,2,2,2,2,2,2,2,1,0,0],[1,2,2,2,2,2,1,1,1,2,2,3,3,2,1,0],[1,2,2,2,2,1,2,2,2,1,2,3,3,2,1,0],[1,2,2,2,1,2,2,2,2,2,1,2,2,2,1,0],[0,1,2,2,1,2,2,2,2,2,2,2,2,1,0,0],[0,1,2,2,1,2,2,2,2,2,2,2,1,0,0,0],[0,0,1,2,2,2,2,2,2,2,2,1,0,0,0,0],[0,0,1,2,2,2,2,2,2,1,1,0,0,0,0,0],[0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],
   FUEL_STATION: [[0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0],[0,0,0,1,3,3,1,0,0,1,3,3,1,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],[1,3,2,3,2,2,2,1,1,2,2,2,3,2,3,1],[1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,0,0,1,3,3,1,0,0,1,3,3,1,0,0,0]],
   WEAPON_CRATE: [[1,1,1,1,1,1,1,1],[1,2,2,2,2,2,2,1],[1,2,1,1,1,1,2,1],[1,2,1,3,3,1,2,1],[1,2,1,3,3,1,2,1],[1,2,1,1,1,1,2,1],[1,2,2,2,2,2,2,1],[1,1,1,1,1,1,1,1]],
   ICON_RAPID: [[0,1,1,0],[1,1,0,0],[0,1,1,0],[0,0,1,1],[0,1,1,0]],
   ICON_BOMB: [[0,1,1,0],[1,1,1,1],[1,1,1,1],[0,1,1,0]],
   ICON_SWIRL: [[1,1,0,1],[0,1,1,0],[1,0,1,1]],
   ICON_SPREAD: [[1,0,1],[0,1,0],[1,0,1]],
   ICON_SHIELD: [[1,1,1],[1,0,1],[1,0,1],[0,1,0]],
   BOSS: [[0,0,1,0,0,0,1,1,1,1,1,0,0,0,1,0,0],[0,1,1,1,0,1,1,2,2,2,1,1,0,1,1,1,0],[1,1,2,1,1,1,2,2,3,2,2,1,1,1,2,1,1],[1,2,2,2,1,2,2,3,3,3,2,2,1,2,2,2,1],[1,2,2,2,1,2,2,3,3,3,2,2,1,2,2,2,1],[1,1,1,1,1,1,1,2,3,2,1,1,1,1,1,1,1],[0,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0],[0,1,0,0,0,0,1,3,1,3,1,0,0,0,0,1,0],[0,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,0],[0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0],[0,0,0,1,0,0,0,1,3,1,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0]]
};


const COLORS = {
   PLAYER: { 1: '#0ff', 2: '#fff', 3: '#f0f', 4: '#555' },
   ENEMY_BUG: { 1: '#f00', 2: '#a00' },
   ENEMY_ASSAULT: { 1: '#0a0', 2: '#0f0', 3: '#fff' },
   METEOR: { 1: '#555', 2: '#777', 3: '#333' },
   FUEL_STATION: { 1: '#333', 2: '#555', 3: '#0f0' },
   WEAPON_CRATE: { 1: '#888', 2: '#aaa', 3: '#0af' },
   BOSS: { 1: '#555', 2: '#f00', 3: '#fff' },
   WALL: { 1: '#444', 2: '#222' },
   RAPID: { 1: '#d0f' },
   SWIRL: { 1: '#3f3' }, // Neon Green
   BOMB: { 1: '#f00', 2: '#fff' },
   SPREAD: { 1: '#ff0' },
   SHIELD: { 1: '#0af' },
   FLASH: { 1:'#fff', 2:'#fff', 3:'#fff', 4:'#fff' }
};


/**
* SPILLMOTOR
*/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');


let gameState = 'MENU';
let score = 0;
let frameCount = 0;
let keys = {};
let screenShake = 0;
let gameSpeed = 3.0; // Start hastighet (høyere)


let player;
let bullets = [];
let enemies = [];
let obstacles = [];
let particles = [];
let stars = [];
let boss = null;


let currentLevel = 1;
let levelTimer = 0;


// Increased base speeds significantly per level
const LEVELS = {
   1: { name: "SECTOR 1: INFILTRATION", length: 1500, spawnRate: 60, types: ['BUG'], baseSpeed: 3.0 },
   2: { name: "SECTOR 2: HEAVY GUARD", length: 1800, spawnRate: 50, types: ['BUG', 'DART'], baseSpeed: 4.0 },
   3: { name: "SECTOR 3: THE GAUNTLET", length: 2000, spawnRate: 40, types: ['DART', 'ASSAULT'], baseSpeed: 5.0 },
   4: { name: "SECTOR 4: BOSS APPROACH", length: 500, spawnRate: 999, types: [], boss: true, baseSpeed: 6.0 },
   5: { name: "ENDLESS TUNNEL", length: 99999, spawnRate: 30, types: ['BUG', 'DART', 'ASSAULT'], boss: false, baseSpeed: 7.0 }
};


const WEAPONS = {
   NORMAL: { name: "PLASMA", color: '#0ff', type: 'single', key: '1' },
   RAPID: { name: "RAPID", color: '#d0f', type: 'single', key: '2' },
   SPREAD: { name: "SPREAD", color: '#ff0', type: 'spread', key: '3' },
   SWIRL: { name: "SWIRL", color: '#3f3', type: 'swirl', key: '4' },
   BOMB: { name: "BOMB", color: '#f00', type: 'bomb', key: '5' }
};


let road = { center: 0, targetCenter: 0, width: 300, targetWidth: 300, noiseOffset: 0, widthNoise: 0 };


function resize() {
   let h = window.innerHeight;
   let w = h * 0.75;
   if (w > window.innerWidth) { w = window.innerWidth; h = w / 0.75; }
   canvas.width = w; canvas.height = h;
   ctx.imageSmoothingEnabled = false;
   road.center = w / 2;
   road.targetCenter = w / 2;
}
window.addEventListener('resize', resize);
resize();


function drawSprite(map, palette, x, y, scale = pixelSize, rotation = 0) {
   if (!map || !palette) return;
   ctx.save();
   const w = map[0].length * scale;
   const h = map.length * scale;
   if (rotation !== 0) { ctx.translate(x + w/2, y + h/2); ctx.rotate(rotation); ctx.translate(-(x + w/2), -(y + h/2)); }
   for (let r = 0; r < map.length; r++) {
       for (let c = 0; c < map[r].length; c++) {
           const val = map[r][c];
           if (val !== 0) {
               ctx.fillStyle = palette[val] || '#fff';
               ctx.fillRect(x + c * scale, y + r * scale, scale, scale);
           }
       }
   }
   ctx.restore();
}


function rectIntersect(r1, r2) {
   return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
}


function createExplosion(x, y, color, count, speed = 1) {
   AudioSys.sfxExplosion();
   for(let i=0; i<count; i++) particles.push(new Particle(x, y, color, speed));
}


function createLevelUpText(x, y) {
   const el = document.createElement('div');
   el.innerText = "LEVEL UP!";
   el.className = "levelup-text";
   el.style.left = (x + canvas.getBoundingClientRect().left) + 'px';
   el.style.top = (y + canvas.getBoundingClientRect().top) + 'px';
   document.body.appendChild(el);
   setTimeout(() => el.remove(), 1000);
}


function checkSpawnOverlap(newObs) {
   const margin = 30;
   const roadLeft = road.center - (road.width / 2);
   const roadRight = road.center + (road.width / 2);
   if (newObs.x < roadLeft + margin || newObs.x + newObs.width > roadRight - margin) return true;
   for(let obs of obstacles) {
       const dx = (newObs.x + newObs.width/2) - (obs.x + obs.width/2);
       const dy = (newObs.y + newObs.height/2) - (obs.y + obs.height/2);
       if (Math.sqrt(dx*dx + dy*dy) < 150) return true;
   }
   return false;
}


/** ENTITETER */
class Entity {
   constructor(x, y, width, height) {
       this.x = x; this.y = y; this.width = width; this.height = height; this.markedForDeletion = false;
       this.flashTimer = 0;
   }
   drawFlash() {
       if(this.flashTimer > 0 && this.map) {
           drawSprite(this.map, COLORS.FLASH, this.x, this.y, this.scale || pixelSize, this.rotation || 0);
           this.flashTimer--;
           return true;
       }
       return false;
   }
}


class Player extends Entity {
   constructor() {
       super(canvas.width/2, canvas.height - 100, 19 * pixelSize, 16 * pixelSize);
       this.speed = 8; this.maxHp = 100; this.hp = 100; this.maxFuel = 100; this.fuel = 100;
       this.weapon = 'NORMAL'; this.weaponLevel = 1; this.shootTimer = 0; this.invulnerable = 0; this.tilt = 0;
       this.shieldTime = 0; this.shieldMax = 600;
       this.inventory = { NORMAL: 1, RAPID: 0, SPREAD: 0, SWIRL: 0, BOMB: 0 };
   }


   update() {
       if (frameCount % 15 === 0) { this.fuel -= 0.5; if (this.fuel <= 0) this.hit(1000, "TOM FOR DRIVSTOFF"); }
       if (this.shieldTime > 0) this.shieldTime--;


       let moved = false;
       if (keys['a'] || keys['ArrowLeft']) { this.x -= this.speed; this.tilt = Math.max(this.tilt - 0.1, -0.8); moved = true; }
       if (keys['d'] || keys['ArrowRight']) { this.x += this.speed; this.tilt = Math.min(this.tilt + 0.1, 0.8); moved = true; }
       if (!moved) { this.tilt *= 0.8; if (Math.abs(this.tilt) < 0.01) this.tilt = 0; }
       if (keys['w'] || keys['ArrowUp']) this.y -= this.speed;
       if (keys['s'] || keys['ArrowDown']) this.y += this.speed;


       this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
       this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));


       if (this.shootTimer > 0) this.shootTimer--;
       if (keys[' '] && this.shootTimer <= 0) this.shoot();
       if (this.invulnerable > 0) this.invulnerable--;


       if (keys['1']) this.switchWeapon('NORMAL');
       if (keys['2']) this.switchWeapon('RAPID');
       if (keys['3']) this.switchWeapon('SPREAD');
       if (keys['4']) this.switchWeapon('SWIRL');
       if (keys['5']) this.switchWeapon('BOMB');


       if(frameCount % 5 === 0) {
           particles.push(new Particle(this.x + this.width/2 - 10 + (this.tilt*10), this.y + this.height, '#0ff', 2));
           particles.push(new Particle(this.x + this.width/2 + 10 + (this.tilt*10), this.y + this.height, '#0ff', 2));
       }
   }


   switchWeapon(type) {
       if (this.inventory[type] > 0) { this.weapon = type; this.weaponLevel = this.inventory[type]; updateUI(); }
   }


   unlockWeapon(type) {
       if (this.inventory[type] < 3) {
           this.inventory[type]++;
           if (this.weapon === type) {
               this.weaponLevel = this.inventory[type];
               createLevelUpText(this.x, this.y);
               AudioSys.sfxLevelUp();
           }
       } else score += 500;
      
       if (this.inventory[type] === 1) this.switchWeapon(type);
   }


   draw() {
       if (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;
       ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(this.tilt);
       ctx.scale(1 - Math.abs(this.tilt)*0.3, 1); ctx.translate(-(this.x + this.width/2), -(this.y + this.height/2));
       drawSprite(SPRITES.PLAYER, COLORS.PLAYER, this.x, this.y);
       ctx.restore();
       if (this.shieldTime > 0) {
           ctx.strokeStyle = `rgba(0, 150, 255, ${Math.random() * 0.5 + 0.5})`; ctx.lineWidth = 3;
           ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width, 0, Math.PI*2); ctx.stroke();
       }
   }


   shoot() {
       const w = WEAPONS[this.weapon]; const cx = this.x + this.width/2 - pixelSize; const lvl = this.weaponLevel;
       let cd = w.type === 'normal' ? 15 : (w.type === 'rapid' ? 8 : (w.type === 'bomb' ? 40 : (w.type === 'spread' ? 20 : 10)));
       if (lvl > 1) cd *= 0.8; this.shootTimer = cd; AudioSys.sfxShoot(w.type);


       if (w.type === 'single' || w.type === 'normal') {
           bullets.push(new Bullet(cx, this.y, 0, -14, w.color, 1, false));
           if (this.weapon === 'RAPID' && lvl >= 2) {
               bullets.push(new Bullet(cx - 10, this.y + 5, 0, -14, w.color, 1, false));
               bullets.push(new Bullet(cx + 10, this.y + 5, 0, -14, w.color, 1, false));
           }
           if (this.weapon === 'RAPID' && lvl >= 3) this.shootTimer = 4; // Gatling mode
       } else if (w.type === 'spread') {
           bullets.push(new Bullet(cx, this.y, 0, -12, w.color, 1, false));
           bullets.push(new Bullet(cx, this.y, -3, -11, w.color, 1, false));
           bullets.push(new Bullet(cx, this.y, 3, -11, w.color, 1, false));
           if (lvl >= 2) { bullets.push(new Bullet(cx, this.y, -6, -10, w.color, 1, false)); bullets.push(new Bullet(cx, this.y, 6, -10, w.color, 1, false)); }
           if (lvl >= 3) { bullets.push(new Bullet(cx, this.y, -9, -9, w.color, 1, false)); bullets.push(new Bullet(cx, this.y, 9, -9, w.color, 1, false)); }
       } else if (w.type === 'swirl') {
           bullets.push(new Bullet(cx, this.y, 0, -10, w.color, 1.5, false, 'swirl', 0));
           if (lvl >= 2) bullets.push(new Bullet(cx, this.y, 0, -10, w.color, 1.5, false, 'swirl', Math.PI));
           if (lvl >= 3) {
               bullets.push(new Bullet(cx, this.y, 0, -10, w.color, 1.5, false, 'swirl', Math.PI/2));
               bullets.push(new Bullet(cx, this.y, 0, -10, w.color, 1.5, false, 'swirl', -Math.PI/2));
           }
       } else if (w.type === 'bomb') {
           bullets.push(new Bullet(cx - 4, this.y, 0, -10, w.color, 5 + (lvl * 2), true, 'straight', 0, false));
           if (lvl >= 3) {
               bullets.push(new Bullet(cx - 15, this.y, -2, -9, w.color, 5, true, 'straight', 0, false));
               bullets.push(new Bullet(cx + 7, this.y, 2, -9, w.color, 5, true, 'straight', 0, false));
           }
       }
   }


   hit(dmg, reason="ØDELAGT AV FIENDE") {
       if (this.shieldTime > 0 && dmg < 1000) return;
       if(this.invulnerable > 0) return;
       this.hp -= dmg;
       this.invulnerable = 40;
       screenShake = 10;
       updateUI();
       createExplosion(this.x + this.width/2, this.y, '#f00', 10);
       if (reason === "KRASJET I VEGG") this.x += (canvas.width/2 - this.x) * 0.1;
       if(this.hp <= 0) gameOver(reason);
   }


   activateShield() {
       this.shieldTime = this.shieldMax;
       AudioSys.sfxPowerup();
       updateUI();
   }
}


class Bullet extends Entity {
   constructor(x, y, vx, vy, color, damage, isBomb = false, pattern = 'straight', offset = 0, isEnemy = false) {
       const size = isBomb ? 12 : 6;
       super(x, y, size, size);
       this.vx = vx; this.vy = vy; this.color = color; this.damage = damage;
       this.isBomb = isBomb; this.pattern = pattern; this.life = 0; this.startX = x; this.offset = offset;
       this.isEnemy = isEnemy;
   }
   update() {
       this.life++; this.y += this.vy;
       if (this.pattern === 'swirl') this.x = this.startX + Math.sin(this.life * 0.2 + this.offset) * 30; else this.x += this.vx;
       if (this.y < -50 || this.y > canvas.height + 50) this.markedForDeletion = true;
   }
   draw() {
       ctx.fillStyle = this.color;
       if (this.isBomb) { ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI*2); ctx.fill(); }
       else ctx.fillRect(this.x, this.y, this.width, this.width * 2);
   }
   explode() {
       if (!this.isBomb) return;
       screenShake = 15; createExplosion(this.x, this.y, '#fa0', 20, 3);
       enemies.forEach(e => { if(Math.hypot(e.x - this.x, e.y - this.y) < 80) e.hit(10); });
   }
}


class Enemy extends Entity {
   constructor(type, x, y) {
       super(x || 0, y || -60, 0, 0);
       this.type = type;
       if (type === 'BUG') {
           this.map = SPRITES.ENEMY_BUG; this.pal = COLORS.ENEMY_BUG;
           this.hp = 2; this.speedY = 3; this.score = 50;
       } else if (type === 'DART') {
           this.map = SPRITES.ENEMY_DART; this.pal = COLORS.ENEMY_DART;
           this.hp = 1; this.speedY = 6; this.score = 100;
       } else if (type === 'ASSAULT') {
           this.map = SPRITES.ENEMY_ASSAULT; this.pal = COLORS.ENEMY_ASSAULT;
           this.hp = 8; this.speedY = 2; this.score = 300;
       }
       if(this.map) {
           this.width = this.map[0].length * pixelSize;
           this.height = this.map.length * pixelSize;
       }
   }
   update() {
       this.y += (this.speedY * (gameSpeed / 1.5));
       if (this.type === 'BUG') this.x += Math.sin(this.y / 30) * 2;
       if (this.y > canvas.height) this.markedForDeletion = true;
   }
   draw() { if(!this.drawFlash()) drawSprite(this.map, this.pal, this.x, this.y); }
   hit(dmg) {
       this.hp -= dmg; this.flashTimer = 4;
       if (this.hp > 0) this.y -= 10;
       if (this.hp <= 0) {
           this.markedForDeletion = true; score += this.score; createExplosion(this.x + this.width/2, this.y + this.height/2, this.pal[1], 10);
       }
   }
}


class Wall extends Entity {
   constructor(x, y, width, height) {
       super(x, y, width, height);
       this.speedY = 1.5;
       this.type = 'WALL'; // Add type property
   }
   update() {
       this.y += gameSpeed;
       if (this.y > canvas.height) this.markedForDeletion = true;
   }
   draw() {
       ctx.fillStyle = COLORS.WALL[1]; ctx.fillRect(this.x, this.y, this.width, this.height);
       ctx.fillStyle = COLORS.WALL[2];
       if (this.width > 20) ctx.fillRect(this.x+5, this.y+5, this.width-10, this.height-10);
   }
}


class Obstacle extends Entity {
   constructor(type, x) {
       super(x, -150, 50, 50);
       this.type = type;
       this.speedY = 1.5;
       this.rotation = 0;
       this.rotSpeed = (Math.random() - 0.5) * 0.05;


       if (type === 'METEOR') {
           this.map = SPRITES.METEOR; this.pal = COLORS.METEOR;
           this.scale = pixelSize * 3; this.hp = 30; // Meteorer tåler skudd
       } else if (type === 'FUEL') {
           this.map = SPRITES.FUEL_STATION; this.pal = COLORS.FUEL_STATION;
           this.scale = pixelSize * 2; this.hp = 999; this.rotSpeed = 0;
       } else if (type === 'WEAPON') {
           this.map = SPRITES.WEAPON_CRATE; this.pal = COLORS.WEAPON_CRATE;
           this.scale = pixelSize * 2; this.hp = 1; this.rotSpeed = 0;
           const r = Math.random();
           if (r < 0.25) this.content = 'RAPID'; else if (r < 0.5) this.content = 'SPREAD'; else if (r < 0.75) this.content = 'SWIRL'; else this.content = 'BOMB';
           if (Math.random() < 0.15) this.content = 'SHIELD';
       }
      
       if(this.map) {
           this.width = this.map[0].length * this.scale;
           this.height = this.map.length * this.scale;
       }
   }


   update() {
       this.y += gameSpeed;
       this.rotation += this.rotSpeed;
       if (this.y > canvas.height) this.markedForDeletion = true;
   }


   draw() {
       if (this.drawFlash()) return;
       drawSprite(this.map, this.pal, this.x, this.y, this.scale, this.rotation);


       if (this.type === 'WEAPON') {
            let icon = SPRITES.ICON_RAPID; let col = COLORS.RAPID[1];
            if(this.content === 'BOMB') { icon = SPRITES.ICON_BOMB; col = COLORS.BOMB[1]; }
            else if(this.content === 'SWIRL') { icon = SPRITES.ICON_SWIRL; col = COLORS.SWIRL[1]; }
            else if(this.content === 'SPREAD') { icon = SPRITES.ICON_SPREAD; col = COLORS.SPREAD[1]; }
            else if(this.content === 'SHIELD') { icon = SPRITES.ICON_SHIELD; col = COLORS.SHIELD[1]; }
            const floatY = Math.sin(frameCount * 0.1) * 5;
            drawSprite(icon, {1: col}, this.x + this.width/2 - (icon[0].length*pixelSize), this.y - 20 + floatY, pixelSize*2);
       }
      
       if (this.type === 'FUEL') {
           if (frameCount % 60 < 30) {
                ctx.fillStyle = "#0f0"; ctx.fillRect(this.x + 10, this.y + 10, 5, 5); ctx.fillRect(this.x + this.width - 15, this.y + 10, 5, 5);
           }
       }
   }


   hit(dmg) {
       if (this.type === 'WEAPON') {
           this.markedForDeletion = true; givePowerup(this.content);
       } else if (this.type === 'METEOR') {
           this.hp -= dmg;
           this.flashTimer = 4;
           if (this.hp <= 0) {
               this.markedForDeletion = true;
               createExplosion(this.x+this.width/2, this.y+this.height/2, '#777', 15);
           }
       }
   }
}


class Boss extends Entity {
   constructor() {
       super(canvas.width/2 - 100, -200, 0, 0);
       this.map = SPRITES.BOSS; this.pal = COLORS.BOSS; this.scale = pixelSize * 4;
       this.width = this.map[0].length * this.scale; this.height = this.map.length * this.scale;
       this.maxHp = 2000; this.hp = this.maxHp; this.state = 'ENTER'; this.vx = 2; this.attackTimer = 0;
   }


   update() {
       if (this.state === 'ENTER') {
           this.y += 0.5;
           if (this.y > 50) { this.y = 50; this.state = 'FIGHT'; document.getElementById('bossHealthContainer').style.display = 'block'; }
       } else if (this.state === 'FIGHT') {
           this.x += this.vx;
           if (this.x <= 0 || this.x + this.width >= canvas.width) this.vx *= -1;
           this.attackTimer++;
           if (this.attackTimer > 50) {
               this.attackTimer = 0; AudioSys.sfxShoot('BOMB');
               const cx = this.x + this.width/2; const cy = this.y + this.height;
               // Skyt RØDE fiendtlige kuler (isEnemy=true)
               for(let i=-2; i<=2; i++) bullets.push(new Bullet(cx, cy, i*2, 6, '#f00', 15, false, 'straight', 0, true));
           }
       }
   }
   draw() { if(!this.drawFlash()) drawSprite(this.map, this.pal, this.x, this.y, this.scale); }
   hit(dmg) {
       if (this.state !== 'FIGHT') return;
       this.hp -= dmg;
       this.flashTimer = 4;
       document.getElementById('bossHealthBar').style.width = (this.hp / this.maxHp * 100) + '%';
       if (this.hp <= 0) {
           this.markedForDeletion = true; score += 10000; boss = null;
           document.getElementById('bossHealthContainer').style.display = 'none';
           for(let i=0; i<30; i++) setTimeout(() => createExplosion(this.x+Math.random()*this.width, this.y+Math.random()*this.height, '#fff', 10, 4), i*50);
           setTimeout(() => startLevel(currentLevel + 1), 4000);
       }
   }
}


class Particle {
   constructor(x, y, color, speedScale = 1) {
       this.x = x; this.y = y; this.color = color;
       this.size = Math.random() * 5 + 3;
       this.vx = (Math.random() - 0.5) * 8 * speedScale;
       this.vy = (Math.random() - 0.5) * 8 * speedScale;
       this.life = 40;
   }
   update() { this.x += this.vx; this.y += this.vy; this.life--; this.size *= 0.9; }
   draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
}


function givePowerup(type) {
   createExplosion(player.x, player.y, '#fff', 20, 2);
   if (type === 'SHIELD') {
       player.activateShield();
   } else {
       AudioSys.sfxPowerup();
       player.unlockWeapon(type);
   }
   updateUI();
}


/** SYSTEM */


function init() {
   AudioSys.init();
   AudioSys.startMusic();
  
   score = 0; currentLevel = 1; levelTimer = 0;
   gameSpeed = 3.0; // Higher start speed
   player = new Player();
   bullets = []; enemies = []; obstacles = []; particles = []; stars = []; boss = null;
  
   road.center = canvas.width / 2;
   road.targetCenter = canvas.width / 2;
   road.width = 400;
  
   for(let i=0; i<80; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, speed: Math.random() * 3 + 1 });


   updateUI();
   startLevel(1);
  
   gameState = 'PLAYING';
   document.getElementById('startScreen').classList.add('hidden');
   document.getElementById('gameOverScreen').classList.add('hidden');
   document.getElementById('uiLayer').classList.remove('hidden');
   document.getElementById('bossHealthContainer').style.display = 'none';
  
   loop();
}


function startLevel(lvlIdx) {
   if (!LEVELS[lvlIdx]) lvlIdx = 5;
   currentLevel = lvlIdx;
   levelTimer = 0;
  
   if(LEVELS[currentLevel].baseSpeed) {
       gameSpeed = LEVELS[currentLevel].baseSpeed;
   }


   const lvlScreen = document.getElementById('levelScreen');
   document.getElementById('levelTitle').innerText = `STAGE ${currentLevel}\n${LEVELS[currentLevel].name}`;
   lvlScreen.classList.remove('hidden');
   setTimeout(() => lvlScreen.classList.add('hidden'), 2000);
}


function spawnBoss() {
   document.getElementById('bossWarning').classList.remove('hidden');
   setTimeout(() => {
       document.getElementById('bossWarning').classList.add('hidden');
       boss = new Boss();
   }, 3000);
}


function updateUI() {
   document.getElementById('scoreDisplay').innerText = score;
   document.getElementById('stageDisplay').innerText = currentLevel;
  
   const w = WEAPONS[player.weapon];
   document.getElementById('weaponDisplay').innerText = w.name;
   document.getElementById('weaponDisplay').style.color = w.color;
   document.getElementById('levelDisplay').innerText = 'LVL ' + player.weaponLevel;
  
   const hint = document.getElementById('keyHintDisplay');
   if (w.key) {
       hint.innerText = w.key;
       hint.style.display = 'inline-block';
   } else {
       hint.style.display = 'none';
   }
  
   document.getElementById('healthBar').style.width = player.hp + '%';
   document.getElementById('healthBar').style.backgroundColor = player.hp > 50 ? '#0f0' : '#f00';
  
   document.getElementById('fuelBar').style.width = player.fuel + '%';
   document.getElementById('fuelBar').style.backgroundColor = player.fuel > 30 ? '#f90' : '#f00';
  
   const sBar = document.getElementById('shieldBar');
   const sLbl = document.getElementById('shieldLabel');
   const sTime = document.getElementById('shieldTimer');
   if (player.shieldTime > 0) {
       sBar.style.width = (player.shieldTime / player.shieldMax * 100) + '%';
       sLbl.style.opacity = 1;
       sTime.innerText = Math.ceil(player.shieldTime / 60) + "s";
   } else {
       sBar.style.width = '0%';
       sLbl.style.opacity = 0;
       sTime.innerText = "";
   }
}


function gameOver(reason) {
   gameState = 'GAMEOVER';
   AudioSys.stopMusic();
   document.getElementById('finalScore').innerText = score;
   document.getElementById('deathReason').innerText = reason;
   document.getElementById('gameOverScreen').classList.remove('hidden');
   document.getElementById('uiLayer').classList.add('hidden');
   document.getElementById('bossHealthContainer').style.display = 'none';
}


function updateLevelGenerator() {
  
   if (!boss && gameSpeed < 10.0) {
       gameSpeed += 0.0002;
   }


   if (boss) {
       road.targetWidth = canvas.width - 50;
       road.targetCenter = canvas.width / 2;
   } else {
       let intensity = 1 + (gameSpeed - 2.0) * 0.5; // Scale slalom with speed
       road.noiseOffset += 0.03 * intensity;
       const noise = Math.sin(road.noiseOffset) + Math.sin(road.noiseOffset * 2.3) * 0.5;
       road.targetCenter = (canvas.width / 2) + (noise * (canvas.width / 2.5));
      
       road.widthNoise += 0.01;
       const widthVar = Math.sin(road.widthNoise * 2) * 200;
       road.targetWidth = 350 + widthVar;
       if (road.targetWidth < 180) road.targetWidth = 180;
   }


   const minCenter = road.width / 2 + 50;
   const maxCenter = canvas.width - (road.width / 2) - 50;
   road.targetCenter = Math.max(minCenter, Math.min(maxCenter, road.targetCenter));


   road.center += (road.targetCenter - road.center) * 0.05;
   road.width += (road.targetWidth - road.width) * 0.02;


   const spawnRate = Math.floor(Math.max(1, 30 / gameSpeed));


   if (!boss && frameCount % spawnRate === 0) {
       const wallHeight = Math.ceil(gameSpeed * spawnRate) + 4;
       const leftWallW = road.center - (road.width / 2);
       const rightWallX = road.center + (road.width / 2);
       const rightWallW = canvas.width - rightWallX;


       if (leftWallW > 0) obstacles.push(new Wall(0, -50, leftWallW, wallHeight));
       if (rightWallW > 0) obstacles.push(new Wall(rightWallX, -50, rightWallW, wallHeight));
   }
}


function spawnEntityInTrack(type) {
   if (boss && type !== 'FUEL' && type !== 'METEOR') return;


   const margin = 40;
   const roadLeft = road.center - (road.width / 2) + margin;
   const roadRight = road.center + (road.width / 2) - margin;
   const width = roadRight - roadLeft;
  
   if (width < 50) return;


   for(let i=0; i<10; i++) {
       const x = roadLeft + Math.random() * (width);
       let temp = { x: x, y: -150, width: 50, height: 50 };
       if (!checkSpawnOverlap(temp)) {
           if (type === 'FUEL') obstacles.push(new Obstacle('FUEL', x));
           else if (type === 'WEAPON') obstacles.push(new Obstacle('WEAPON', x));
           else if (type === 'METEOR') obstacles.push(new Obstacle('METEOR', x));
           else if (['BUG', 'DART', 'ASSAULT'].includes(type)) enemies.push(new Enemy(type, x));
           return;
       }
   }
}


function loop() {
   if (gameState !== 'PLAYING') return;
   requestAnimationFrame(loop);


   let shakeX = 0, shakeY = 0;
   if (screenShake > 0) {
       shakeX = (Math.random() - 0.5) * screenShake; shakeY = (Math.random() - 0.5) * screenShake;
       screenShake *= 0.9; if(screenShake < 0.5) screenShake = 0;
   }


   ctx.save();
   ctx.translate(shakeX, shakeY);


   ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, canvas.width, canvas.height);
   ctx.fillStyle = '#aaa';
   stars.forEach(s => {
       s.y += s.speed * (gameSpeed / 1.5);
       if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; }
       ctx.fillRect(s.x, s.y, s.speed > 2 ? 2 : 1, s.speed > 2 ? 2 : 1);
   });


   if (!boss) {
       levelTimer++;
       const levelData = LEVELS[currentLevel] || LEVELS[5];
       updateLevelGenerator();


       if (levelTimer < levelData.length) {
           const speedMod = 2.0 / gameSpeed;
           if (frameCount % Math.floor(Math.max(1, levelData.spawnRate * speedMod)) === 0) {
               const type = levelData.types[Math.floor(Math.random() * levelData.types.length)];
               if (type) spawnEntityInTrack(type);
           }
           if (frameCount % Math.floor(800 * speedMod) === 0) spawnEntityInTrack('FUEL');
           if (frameCount % Math.floor(250 * speedMod) === 0) spawnEntityInTrack('WEAPON');


       } else if (enemies.length === 0 && levelTimer >= levelData.length) {
           if (levelData.boss) { spawnBoss(); }
           else { startLevel(currentLevel + 1); }
       }
   } else {
       updateLevelGenerator();
       if (frameCount % 200 === 0) spawnEntityInTrack('METEOR');
       if (frameCount % 600 === 0) spawnEntityInTrack('FUEL');  
   }


   player.update();
   player.draw();
  
   if (boss) {
       boss.update(); boss.draw();
       if (rectIntersect(player, boss)) player.hit(100, "KNUST AV BOSS");
   }


   bullets.forEach(b => {
       b.update(); b.draw();
      
       if (!b.isEnemy) {
           enemies.forEach(e => {
               if (!b.markedForDeletion && !e.markedForDeletion && rectIntersect(b, e)) {
                   b.markedForDeletion = true; if (b.isBomb) b.explode(); e.hit(b.damage);
               }
           });
           if (boss && !b.markedForDeletion && rectIntersect(b, boss)) {
                b.markedForDeletion = true; if (b.isBomb) b.explode(); boss.hit(b.damage);
           }
           obstacles.forEach(o => {
               if (o.type === 'METEOR' && !b.markedForDeletion && !o.markedForDeletion && rectIntersect(b, o)) {
                   b.markedForDeletion = true; if (b.isBomb) b.explode(); o.hit(b.damage);
               }
           });
       }
      
       if (b.isEnemy) {
           if (!b.markedForDeletion && rectIntersect(b, player)) {
               b.markedForDeletion = true;
               player.hit(b.damage, "SKUTT AV FIENDE");
           }
           obstacles.forEach(o => {
               if (o.type === 'METEOR' && !b.markedForDeletion && !o.markedForDeletion && rectIntersect(b, o)) {
                   b.markedForDeletion = true;
                   createExplosion(b.x, b.y, '#fa0', 5);
               }
           });
       }


       obstacles.forEach(o => {
           if (!b.isEnemy && !b.markedForDeletion && !o.markedForDeletion && rectIntersect(b, o)) {
                if (o.type === 'WEAPON') {
                    b.markedForDeletion = true; if (b.isBomb) b.explode(); o.hit(1);
                } else if (o.type === 'WALL') {
                    b.markedForDeletion = true; if (b.isBomb) b.explode();
                    createExplosion(b.x, b.y, '#555', 3);
                }
           }
       });
   });


   enemies.forEach(e => {
       e.update(); e.draw();
       if (!e.markedForDeletion && rectIntersect(player, e)) {
            e.hit(10); player.hit(20, "KOLLISJON MED FIENDE");
       }
   });


   obstacles.forEach(o => {
       o.update(); o.draw();
       if (!o.markedForDeletion && rectIntersect(player, o)) {
           if (o.type === 'FUEL') {
                o.markedForDeletion = true;
                player.fuel = 100;
                AudioSys.sfxFuel();
                updateUI();
                createExplosion(player.x, player.y, '#0f0', 15, 2);
           } else if (o.type === 'WEAPON') {
                o.markedForDeletion = true;
                givePowerup(o.content);
           } else if (o.type === 'METEOR') {
                o.markedForDeletion = true;
                createExplosion(o.x+o.width/2, o.y+o.height/2, '#888', 20);
                player.hit(30, "KNUST AV METEOR");
           } else if (o.type === 'WALL') {
                player.hit(20, "KRASJET I VEGG");
           }
       }
   });


   particles.forEach(p => { p.update(); p.draw(); });


   bullets = bullets.filter(b => !b.markedForDeletion);
   enemies = enemies.filter(e => !e.markedForDeletion);
   obstacles = obstacles.filter(o => !o.markedForDeletion);
   particles = particles.filter(p => p.life > 0);


   frameCount++;
   ctx.restore();
  
   updateUI();
}


window.addEventListener('keydown', e => {
   keys[e.key] = true;
   if(e.key === " ") e.preventDefault();
});
window.addEventListener('keyup', e => keys[e.key] = false);


canvas.addEventListener('touchstart', e => {
   e.preventDefault();
   const rect = canvas.getBoundingClientRect();
   const touchX = e.touches[0].clientX - rect.left;
   keys[' '] = true;
   if(touchX < canvas.width / 2) { keys['a'] = true; keys['d'] = false; }
   else { keys['d'] = true; keys['a'] = false; }
}, {passive: false});


canvas.addEventListener('touchend', e => { keys['a'] = false; keys['d'] = false; keys[' '] = false; });


document.getElementById('startBtn').addEventListener('click', init);
document.getElementById('restartBtn').addEventListener('click', init);


</script>
</body>
</html>

